from datetime import datetime
import io
import json
import os
from pathlib import Path
import unicodedata
import pandas as pd
import fitz
import base64
import streamlit as st
import tempfile
from dateutil import parser
from dotenv import load_dotenv
import re
from openai import OpenAI
import dataframe_image as dfi
import openpyxl
from openpyxl.styles import Font

load_dotenv()


def sanitize_excel_sheet_name(name: str) -> str:
    """
    Sanitize an Excel sheet name by removing forbidden characters and limiting it to 31 characters.
    
    Forbidden characters are: `[:\/\\\?\*\[\]\,]`.
    The sanitized name is returned in uppercase.
    
    Args:
        name (str): The name to sanitize.
        
    Returns:
        str: The sanitized name.
    """
    forbidden_chars = r'[:\/\\\?\*\[\]\,]'
    clean_name = re.sub(forbidden_chars, "", name).upper()
    return clean_name[:31]


def normalize_excel_sheet_name(name: str) -> str:
    """
    Normalize an Excel sheet name by removing accents and converting to lowercase.

    This function is used to sanitize Excel sheet names before writing them to an Excel file.
    It uses the unicodedata.normalize() function to remove accents from the name, and then
    converts the name to lowercase and removes any whitespace characters.

    Args:
        name (str): The name to normalize.

    Returns:
        str: The normalized name.
    """
    name = unicodedata.normalize("NFKD", name).encode("ascii", "ignore").decode()
    name = name.lower()
    name = re.sub(r"[^a-z0-9]", "", name)
    return name


def to_french_date(date_str: str) -> str:
    MONTHS_FR_EN = {
    "janvier": "january",
    "f√©vrier": "february",
    "fevrier": "february",
    "mars": "march",
    "avril": "april",
    "mai": "may",
    "juin": "june",
    "juillet": "july",
    "ao√ªt": "august",
    "aout": "august",
    "septembre": "september",
    "octobre": "october",
    "novembre": "november",
    "d√©cembre": "december",
    "decembre": "december",
    }
    if not date_str:
        return None
    date_str = date_str.lower()
    for fr, en in MONTHS_FR_EN.items():
        date_str = date_str.replace(fr, en)
    try:
        print(f"date_str: {date_str}")
        dt = parser.parse(date_str, dayfirst=True)
        print(f"dt: {dt}")
        return dt.strftime("%d/%m/%Y")
    except Exception as e:
        print(f"Error converting {date_str}: {e}")
        return date_str


def invoice_to_image(invoice):
    """
    Convert an invoice to an image.

    This function takes an invoice as an argument (which should be a file-like object)
    and returns a list of base64 encoded images.

    The images are converted from the invoice depending on the file type. If the file type is
    PDF, the images are extracted by rendering the PDF pages as images. If the file type is
    a JPEG or PNG, the image is read directly from the file. If the file type is an Excel file,
    the images are generated by rendering the Excel sheet as an image.

    Args:
        invoice (file-like object): The invoice to convert to an image.

    Returns:
        list[str]: A list of base64 encoded images.
    """
    suffix = "." + invoice.name.split(".")[-1].lower()
    with tempfile.NamedTemporaryFile(suffix=suffix, delete=False) as tmp_file:
     invoice.seek(0)
     tmp_file.write(invoice.read())
     path = Path(tmp_file.name)
    list_b64 = []
    if suffix in [".pdf", ".PDF"]:
        doc = fitz.open(path)
        matrix = fitz.Matrix(2, 2) 
        for page in doc:
            # Convert to image
            pix = page.get_pixmap(matrix=matrix)
            img_bytes = pix.tobytes("jpeg")
            try:
                base64_image = base64.b64encode(img_bytes).decode("utf-8")
            except Exception as e: 
                print(f"Error: {e}")
                return None
            url= f"data:image/jpeg;base64,{base64_image}"
            list_b64.append(url)
    elif suffix.lower() in [".jpg", ".jpeg", ".png", ".JPG", ".JPEG", ".PNG"]:
        with open(path, "rb") as f:
            try:
                base64_image = base64.b64encode(f.read()).decode("utf-8")
            except Exception as e: 
                print(f"Error: {e}")
                return None
            mime = "jpeg" if suffix.lower() in [".jpg", ".jpeg"] else "png"
            url= f"data:image/{mime};base64,{base64_image}"
            list_b64.append(url)
    else:
        df = pd.read_excel(path, sheet_name=None)
        df = next(iter(df.values()))
        with tempfile.NamedTemporaryFile(suffix=".jpeg", delete=False) as img_tmp:
            dfi.export(df, img_tmp.name, table_conversion="pillow")
            with open(img_tmp.name, "rb") as f:
                img_bytes = f.read()
        try:
            base64_image = base64.b64encode(img_bytes).decode("utf-8")
        except Exception as e: 
            print(f"Error: {e}")
            return None
        url = f"data:image/jpeg;base64,{base64_image}"
        list_b64.append(url)
    return list_b64
    

def fill_excel_file(list_revenues_dict, list_expenses_dict):
    """
    Fill an Excel file with data from list_revenues_dict and list_expenses_dict.

    The function takes two parameters: list_revenues_dict and list_expenses_dict.
    list_revenues_dict should contain a list of dictionaries with the following keys:
        - "invoice_reference": a dictionary with "number" and "date" keys.
        - "client_name": a string with the client name.
        - "deposit_paid": a float with the deposit paid amount.
    list_expenses_dict should contain a list of dictionaries with the following keys:
        - "total_ttc": a float with the total expenses amount.
        - "vat_5.5_amount": a float with the vat 5.5% amount.
        - "vat_10_amount": a float with the vat 10% amount.
        - "vat_20_amount": a float with the vat 20% amount.

    The function returns an ExcelWriter object containing two sheets: "Recettes" and "D√©penses".
    """
    rows_revenues = []
    rows_expenses = []

    for invoice in list_revenues_dict:
        # Revenues
        deposit_paid_ht = invoice.get("deposit_paid", 0)
        deposit_paid_ht = abs(float(deposit_paid_ht))
        vat_5_5 = deposit_paid_ht * 0.055
        vat_10 = deposit_paid_ht * 0.1
        vat_20 = deposit_paid_ht * 0.2

        date = invoice.get("invoice_reference", {}).get("date", "")
        date = to_french_date(date)

        row_rev = {
            "N¬∞ FACTURE": invoice.get("invoice_reference", {}).get("number", None),
            "Date": date,
            "Date_dt": datetime.strptime(date, "%d/%m/%Y"),
            "Nom du client": invoice.get("client_name", ""),
            "HT": deposit_paid_ht,
            "TVA 5.5%": vat_5_5,
            "TVA 10%": vat_10,
            "TVA 20%": vat_20,
            "TTC": deposit_paid_ht + vat_5_5  + vat_10 + vat_20,
        }
        rows_revenues.append(row_rev)
    rows_revenues = sorted(rows_revenues, key=lambda x: x["Date_dt"] or datetime.min)
    for invoice in list_expenses_dict:
        # Expenses
        date = invoice.get("date", "")
        date = to_french_date(date)
        total_ttc = invoice.get("total_ttc", 0) or 0
        vat_5_5_exp = invoice.get("vat_5.5_amount", 0) or 0
        vat_10_exp = invoice.get("vat_10_amount", 0) or 0
        vat_20_exp = invoice.get("vat_20_amount", 0) or 0
        row_exp = {
            "Date": date,
            "Date_dt": datetime.strptime(date, "%d/%m/%Y"),
            "HT": total_ttc - (vat_5_5_exp + vat_10_exp + vat_20_exp),
            "TVA 5.5%": vat_5_5_exp,
            "TVA 10%": vat_10_exp,
            "TVA 20%": vat_20_exp,
            "TTC": total_ttc,
        }
        rows_expenses.append(row_exp)
    rows_expenses = sorted(rows_expenses, key=lambda x: x["Date_dt"] or datetime.min)
    # Sum revenues subtotal
    columns_revenues = list(rows_revenues[0].keys())
    empty_row_revenues = {col: "" for col in columns_revenues}
    sum_rev_ht = sum(row.get("HT", 0) or 0 for row in rows_revenues)
    sum_rev_vat_5_5 = sum(row.get("TVA 5.5%", 0) or 0 for row in rows_revenues)
    sum_rev_vat_10 = sum(row.get("TVA 10%", 0) or 0 for row in rows_revenues)
    sum_rev_vat_20 = sum(row.get("TVA 20%", 0) or 0 for row in rows_revenues)
    sum_rev_ttc = sum(row.get("TTC", 0) or 0 for row in rows_revenues)
    rows_revenues.append(empty_row_revenues)
    row_rev_sum = {
        "N¬∞ FACTURE": "",
        "Date": "",
        "Date_dt": "",
        "Nom du client": "SOUS TOTAL",
        "HT": sum_rev_ht,
        "TVA 5.5%": sum_rev_vat_5_5,
        "TVA 10%": sum_rev_vat_10,
        "TVA 20%": sum_rev_vat_20,
        "TTC": sum_rev_ttc,
    }
    rows_revenues.append(row_rev_sum)    
    rows_revenues.append(empty_row_revenues)
    # Sum revenues total
    row_rev_sum_ht = {col: "" for col in columns_revenues}
    row_rev_sum_ht["N¬∞ FACTURE"] = "TOTAL HT"
    row_rev_sum_ht["Date"] = sum_rev_ht
    rows_revenues.append(row_rev_sum_ht)
    row_rev_sum_vat = {col: "" for col in columns_revenues}
    row_rev_sum_vat["N¬∞ FACTURE"] = "TOTAL TVA"
    row_rev_sum_vat["Date"] = sum_rev_vat_5_5 + sum_rev_vat_10 + sum_rev_vat_20
    rows_revenues.append(row_rev_sum_vat)
    row_rev_sum_ttc = {col: "" for col in columns_revenues}
    row_rev_sum_ttc["N¬∞ FACTURE"] = "TOTAL TTC"
    row_rev_sum_ttc["Date"] = sum_rev_ttc
    rows_revenues.append(row_rev_sum_ttc)
    # Sum expenses subtotal
    columns_expenses = list(rows_expenses[0].keys())
    empty_row_expenses = {col: "" for col in columns_expenses}
    sum_exp_ht = sum(row.get("HT", 0) or 0 for row in rows_expenses)
    sum_exp_vat_5_5 = sum(row.get("TVA 5.5%", 0) or 0 for row in rows_expenses)
    sum_exp_vat_10 = sum(row.get("TVA 10%", 0) or 0 for row in rows_expenses)
    sum_exp_vat_20 = sum(row.get("TVA 20%", 0) or 0 for row in rows_expenses)
    sum_exp_ttc = sum(row.get("TTC", 0) or 0 for row in rows_expenses)
    rows_expenses.append(empty_row_expenses)
    row_exp_sum = {
        "Date": "SOUS TOTAL",
        "Date_dt": "",
        "HT": sum_exp_ht,
        "TVA 5.5%": sum_exp_vat_5_5,
        "TVA 10%": sum_exp_vat_10,
        "TVA 20%": sum_exp_vat_20,
        "TTC": sum_exp_ttc,
    }
    rows_expenses.append(row_exp_sum)
    rows_expenses.append(empty_row_expenses)
    # Sum expenses total
    row_exp_sum_ht = {col: "" for col in columns_expenses}
    row_exp_sum_ht["Date"] = "TOTAL HT"
    row_exp_sum_ht["HT"] = sum_exp_ht
    rows_expenses.append(row_exp_sum_ht)
    row_exp_sum_vat = {col: "" for col in columns_expenses}
    row_exp_sum_vat["Date"] = "TOTAL TVA"
    row_exp_sum_vat["HT"] = sum_exp_vat_5_5 + sum_exp_vat_10 + sum_exp_vat_20
    rows_expenses.append(row_exp_sum_vat)
    row_exp_sum_ttc = {col: "" for col in columns_expenses}
    row_exp_sum_ttc["Date"] = "TOTAL TTC"
    row_exp_sum_ttc["HT"] = sum_exp_ttc
    rows_expenses.append(row_exp_sum_ttc)
    rows_expenses.append(empty_row_expenses)
    # VAT to pay
    row_vat_to_pay = {col: "" for col in columns_expenses}
    row_vat_to_pay["Date"] = "TVA √† payer"
    row_vat_to_pay["HT"] = row_rev_sum_vat["Date"] - row_exp_sum_vat["HT"]
    rows_expenses.append(row_vat_to_pay)
    # Convert to DataFrame
    df_revenues = pd.DataFrame(rows_revenues)
    df_revenues = df_revenues.drop(columns=["Date_dt"])
    df_expenses = pd.DataFrame(rows_expenses)
    df_expenses = df_expenses.drop(columns=["Date_dt"])
    # Write to Excel
    excel_buffer = io.BytesIO()
    with pd.ExcelWriter(excel_buffer, engine="openpyxl") as writer:
        df_revenues.to_excel(writer, index=False, sheet_name="Recettes")
        df_expenses.to_excel(writer, index=False, sheet_name="D√©penses")
        # Format Excel
        bold_font = Font(bold=True)
        for sheet_name in writer.sheets:
            worksheet = writer.sheets[sheet_name]
            last_row = worksheet.max_row
            for col in range(1, worksheet.max_column + 1):
                worksheet.cell(row=last_row, column=col).font = bold_font
                worksheet.column_dimensions[openpyxl.utils.get_column_letter(col)].width = 35
    excel_path = Path("bilan_comptable.xlsx")
    st.success(f"""Le fichier Excel {excel_path} a √©t√© cr√©e avec les recettes des {len(list_revenues_dict)} factures 
               et les d√©penses des {len(list_expenses_dict)} notes de frais que vous avez fournies.üòÉüî•""")
    warning_box = st.empty()
    warning_box.warning(f"‚ö†Ô∏è L'IA peut faire des erreurs, pensez √† veÃÅrifier syst√©matiquement le contenu du fichier Excel.")
    st.download_button(label="TeÃÅleÃÅcharger le fichier Excel", data=excel_buffer, file_name=str(excel_path))


def call_llm(files, tools):
    list_invoices_dict = []
    for invoice in files:
        list_images = invoice_to_image(invoice)
        messages = [{"role":"user", "content": []}]
        for image_url in list_images:
            messages[0]["content"].append({"type":"input_image", "image_url":image_url})
        data = {
                "model": "gpt-4.1",
                "input": messages,
                "tools": tools,
                "tool_choice": {"type": tools[0]["type"], "name": tools[0]["name"]},
                "temperature": 0,
                }
        for attempt in range(1,4):
            try:
                print("api gpt call")
                client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
                response = client.responses.create(**data)
                final_response = response.output[0].to_json()
                if isinstance(final_response, dict):
                    invoice_dict = final_response.get("arguments", None)
                    invoice_dict = json.loads(invoice_dict)
                elif isinstance(final_response, str):
                    invoice_dict = json.loads(final_response)
                    invoice_dict = invoice_dict.get("arguments", None)
                    invoice_dict = json.loads(invoice_dict)
                else:
                    raise TypeError(f"final_response is not a string or a dict, it's a {type(final_response)}")
                list_invoices_dict.append(invoice_dict)
                break
            except Exception as e:
                print(f"Attempt {attempt}/3 \n API call failed with error: {e} - retrying...")
    return list_invoices_dict


tools_revenues = [{
    "type":"function",
    "name": "extract_revenues_data",
    "description": "Extract structured data from an invoice",
    "strict": True,
    "parameters": {
        "type": "object",
        "properties": {
            "client_name": {
                "type": "string",
                "description": "Name of the client as written on the invoice. Located immediately below the invoice date."
            },
             "invoice_reference": {
                "type": "object",
                "description": "Invoice reference as written on the document",
                "properties": {
                    "number": {
                        "type": "string",
                        "description": "Invoice number only, extracted from the invoice header. Do NOT include words. Ex: '2022/05/32'"
                    },
                    "date": {
                        "type": "string",
                        "description": "Date found near the invoice number or in the header, even if unlabeled or on a separate line (e.g. '14-08-2024')"
                    },
                },
                "required": ["number", "date"],
                "additionalProperties": False
            },
            "deposit_paid": {
                "type": "number",
                "description": "Amount of deposit (acompte) already paid, last amount written as a negative value."
            },
        },
        "required": ["client_name", "invoice_reference", "deposit_paid"],
        "additionalProperties": False
    }
}]

tools_expenses = [{
    "type":"function",
    "name": "extract_expenses_data",
    "description": "Extract structured data from an invoice",
    "strict": True,
    "parameters": {
        "type": "object",
        "properties": {
            "date": {
                "type": "string",
                "description": "Date found near the invoice number or in the header, even if unlabeled or on a separate line (e.g. '14-08-2024')"
            },
            "total_ttc": {
                "type": ["number", "null"],
                "description": "Total amount including tax (TTC) in euros, exactly as written on the invoice. Null if not present.",
            },
            "vat_5.5_amount": {
                "type": ["number", "null"],
                "description": "VAT amount in euros for the 5.5% VAT rate. Null if not present in the invoice.",
            },
            "vat_10_amount": {
                "type": ["number", "null"],
                "description": "VAT amount in euros for the 10% VAT rate. Null if not present in the invoice.",
            },
            "vat_20_amount": {
                "type": ["number", "null"],
                "description": "VAT amount in euros for the 20% VAT rate. Null if not present in the invoice.",
            },

        },
        "required": ["date", "total_ttc", "vat_5.5_amount", "vat_10_amount", "vat_20_amount"],
        "additionalProperties": False
    }
}]
st.title("Recettes et d√©penses")
revenues = st.file_uploader("Recettes", type=["csv", "xlsx"], accept_multiple_files=True)
expenses = st.file_uploader("D√©penses", type=["pdf", "png", "jpg"], accept_multiple_files=True)
if st.button("Lancer le traitement"):
    if not revenues and not expenses:
        st.error("Veuillez fournir des factures")
    else:
        list_revenues_dict = call_llm(revenues, tools_revenues)
        list_expenses_dict = call_llm(expenses, tools_expenses)
        fill_excel_file(list_revenues_dict, list_expenses_dict)
  
  







        
